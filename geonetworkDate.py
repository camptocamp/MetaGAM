# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MetaGAMDialog
                                 A QGIS plugin
 Plugin qui permet de gérer les métadonnées uniques à la métropole de Grenoble.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-20
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Service SIT - Amr HAMADEH
        email                : demande_sit@grenoblealpesmetropole.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
### Importer les bibliotheques nécessaires
import os
from qgis.core import QgsProject
from qgis.core import *
import re
from PyQt5 import QtWidgets
from qgis.PyQt import *
from qgis.PyQt import QtWidgets, QtCore, QtGui
from qgis.PyQt.QtWidgets import *
import requests
from requests.structures import CaseInsensitiveDict
#from pandas import *
from qgis.core import QgsVectorFileWriter
import json
import xml.etree.ElementTree as ET

def connexionGeonetwork(user,password):
    """_summary_

    Cette fonction établis la connexion avec le serveur Geonetwork en utilisant son API. La fonction utilise la bibliothèque Python requests pour envoyer des requêtes HTTP au serveur GeoNetwork et récupérer des informations. Elle envoie deux requêtes GET à deux endpoints différents du serveur, en incluant les informations d'authentification de l'utilisateur. La première requête est utilisée pour récupérer un cookie de session, qui est stocké localement dans un fichier cookie.txt. La seconde requête est utilisée pour récupérer les informations de profil de l'utilisateur.
    
    Args:
        user (str): nom d'utilisateur saisie dans le plugin.
        password (str): mot de pass saisie dans le plugin.
        
    Returns:
        res (booléen): un booléen qui indique si la connexion a réussi ou échoué.
        CATALOG (str): l'URL de base du serveur GeoNetwork utilisé.
        token(str): le jeton de sécurité XSRF utilisé pour les requêtes.
        headers(str): les en-têtes HTTP utilisés pour les requêtes.
        user(str): le nom d'utilisateur utilisé pour se connecter.
        password(str): le mot de passe utilisé pour se connecter.
        group(int): le groupe d'utilisateurs auquel appartient l'utilisateur connecté, ou None si aucun groupe n'a été trouvé
    """
    CATALOG="https://geonetworkt.grenoblealpesmetropole.fr/geonetwork"        
    response = requests.post(CATALOG+"/srv/eng/info?type=me")
    current_file_path = os.path.realpath(__file__)
    temp_file = os.path.join(os.path.dirname(current_file_path), "temp")
    if not os.path.exists(temp_file):
        os.makedirs(temp_file)
    with open(temp_file+"/cookie.txt", "w") as cookie:
        cookie.write(str(response.cookies))
    file_one = open(temp_file+"/cookie.txt", "r")
    text=file_one.read()
    start = 'XSRF-TOKEN='
    end = ' for'
    token=text[text.find(start)+len(start):text.rfind(end)]
    file_one.close()
    headers = CaseInsensitiveDict()
    headers["Accept"] = "application/json"
    headers["X-XSRF-TOKEN"] = token
    response_author = requests.get(CATALOG+"/srv/eng/info?type=me", 
                    headers=headers, cookies = {"XSRF-TOKEN": token},
                    auth=(user,password))
    response_info = requests.get(CATALOG + "/srv/api/me",
                        headers=headers,
                        cookies={"XSRF-TOKEN": token},
                        auth=(user, password))
    if(response_author.status_code)==200:
        res = True
        res_text = response_info.text
        res_json = json.loads(res_text)
        profile = res_json["profile"]
        if profile == "Reviewer":
            group = res_json["groupsWithReviewer"][0]
        elif profile == "Editor":
            group = res_json["groupsWithEditor"][0]
        elif profile == "UserAdmin":
            group = res_json["groupsWithUserAdmin"][0]
        else:
            group = None
    else:
        res = False
        group = None
    return(res,CATALOG,token,headers,user,password,group)

def postMetaGN(user,password):
    """_summary_

    Cette fonction  permet de poster des fichiers de métadonnées sur GeoNetwork. Elle utilise la fonction connexionGeonetwork pour établir une connexion à l'instance de GeoNetwork en fournissant les informations d'authentification de l'utilisateur. Et fais la mise à jour des fiches (si la fiche de métadonnées existe déja alors elle sera écrasée par la nouvelle fiche).

    Args:
        user (str): nom d'utilisateur saisie dans le plugin.
        password (str): mot de pass saisie dans le plugin.
    """
    connexionGN=connexionGeonetwork(user,password)
    userGroup = connexionGN[6]
    current_file_path = os.path.abspath(__file__)
    temp_file = os.path.join(os.path.dirname(current_file_path), "temp") 
    if userGroup == None:
        for filename in os.listdir(temp_file):
            file_path = os.path.join(temp_file, filename)
            if filename.endswith('.zip'):
                with open(temp_file+"/"+filename, 'rb') as file:
                    file_obj = file.read()
                    file_basename = os.path.basename(filename)
                    file_to_upload = {"file": (str(file_basename), file_obj)}
                    finfo = {"fullPath": filename}
                    response = requests.post(connexionGN[1]+"/srv/api/records?metadataType=METADATA&uuidProcessing=OVERWRITE&transformWith=_none_", 
                            headers=connexionGN[3],
                            cookies = {"XSRF-TOKEN": connexionGN[2]},
                            auth=(connexionGN[4],connexionGN[5]),
                            files=file_to_upload,
                            data=finfo)
    else:   
        userGroup = str(userGroup)
        current_file_path = os.path.abspath(__file__)
        temp_file = os.path.join(os.path.dirname(current_file_path), "temp") 
        for filename in os.listdir(temp_file):
            file_path = os.path.join(temp_file, filename)
            if filename.endswith('.zip'):
                with open(temp_file+"/"+filename, 'rb') as file:
                    file_obj = file.read()
                    file_basename = os.path.basename(filename)
                    file_to_upload = {"file": (str(file_basename), file_obj)}
                    finfo = {"fullPath": filename}
                    response = requests.post(connexionGN[1]+"/srv/api/records?metadataType=METADATA&uuidProcessing=OVERWRITE&group="+userGroup+"&transformWith=_none_", 
                            headers=connexionGN[3],
                            cookies = {"XSRF-TOKEN": connexionGN[2]},
                            auth=(connexionGN[4],connexionGN[5]),
                            files=file_to_upload,
                            data=finfo)            


def getMetaDateGN(user,password,uuid):
    """_summary_

    Cette fonction récupere la date de publication pour une fiche donnée .Elle utilise la fonction connexionGeonetwork pour établir une connexion à l'instance de GeoNetwork en fournissant les informations d'authentification de l'utilisateur.

    Args:
        user (str): nom d'utilisateur saisie dans le plugin.
        password (str): mot de pass saisie dans le plugin.
        uuid (str): identifiant fiche de métadonnées.
    """
    connexionGN=connexionGeonetwork(user,password)
    userGroup = connexionGN[6]
    headersGN = connexionGN[3]
    headersGN["Accept"] = "application/xml"
    headersGN["Content-Type"] = "application/xml"
    response = None
    if userGroup == None:
        response = requests.get(connexionGN[1]+"/srv/api/records/"+uuid+"/formatters/xml?addSchemaLocation=false&increasePopularity=false&approved=false", 
                headers=headersGN,
                cookies = {"XSRF-TOKEN": connexionGN[2]},
                auth=(connexionGN[4],connexionGN[5]))
    if response.status_code == 200:
        reponse_xml = response.text
        root = ET.fromstring(reponse_xml)
        date_element = root.find(".//{http://www.isotc211.org/2005/gco}Date")
        date_publication = date_element.text
        return(date_publication)
