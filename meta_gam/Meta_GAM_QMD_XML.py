# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MetaGAMDialog
                                 A QGIS plugin
 Plugin qui permet de gérer les métadonnées uniques à la métropole de Grenoble.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-20
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Service SIT - Amr HAMADEH
        email                : demande_sit@grenoblealpesmetropole.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

### Importer les bibliotheques nécessaires
import os
import zipfile
from datetime import datetime
from xml.dom import minidom
from xml.etree import ElementTree
from xml.etree.ElementTree import Element, SubElement
from PyQt5.QtCore import *
from PyQt5.QtGui import *
import lxml.etree as lxml
from qgis.core import *
import xml.etree.ElementTree as ET
import shutil
import xml.dom.minidom

### Variables locales pour les chemins des fichiers
current_file_path = os.path.abspath(__file__)
ISO_file_path = os.path.join(os.path.dirname(current_file_path), "resources")
temp_file = os.path.join(os.path.dirname(current_file_path), "temp")
new_xml_block = """
    <gmd:pointOfContact xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gco="http://www.isotc211.org/2005/gco">
        <gmd:CI_ResponsibleParty>
            <gmd:individualName>
                <gco:CharacterString></gco:CharacterString>
            </gmd:individualName>
            <gmd:organisationName>
                <gco:CharacterString>Grenoble Alpes Métropole</gco:CharacterString>
            </gmd:organisationName>
            <gmd:positionName>
                <gco:CharacterString>Grenoble Alpes Métropole</gco:CharacterString>µ
            </gmd:positionName>
            <gmd:contactInfo>
                <gmd:CI_Contact>
                    <gmd:phone>
                        <gmd:CI_Telephone>
                            <gmd:voice>
                            </gmd:voice>
                            <gmd:facsimile>
                                <gco:CharacterString/>
                            </gmd:facsimile>
                        </gmd:CI_Telephone>
                    </gmd:phone>
                    <gmd:address>
                        <gmd:CI_Address>
                            <gmd:deliveryPoint>
                                <gco:CharacterString>3 Rue Malakoff</gco:CharacterString>
                            </gmd:deliveryPoint>
                            <gmd:city>
                                <gco:CharacterString>Grenoble</gco:CharacterString>
                            </gmd:city>
                            <gmd:administrativeArea>
                                <gco:CharacterString/>
                            </gmd:administrativeArea>
                            <gmd:postalCode>
                                <gco:CharacterString>38100</gco:CharacterString>
                            </gmd:postalCode>
                            <gmd:country>
                                <gco:CharacterString/>
                            </gmd:country>
                            <gmd:electronicMailAddress>
                                <gco:CharacterString></gco:CharacterString>
                            </gmd:electronicMailAddress>
                        </gmd:CI_Address>
                    </gmd:address>
                </gmd:CI_Contact>
            </gmd:contactInfo>
            <gmd:role>
                <gmd:CI_RoleCode codeList="http://standards.iso.org/ittf/PubliclyAvailableStandards/ISO_19139_Schemas/resources/codelist/ML_gmxCodelists.xml#CI_RoleCode" codeListValue="owner"/>
            </gmd:role>
        </gmd:CI_ResponsibleParty>
    </gmd:pointOfContact>
"""


def saveTempQmd(layer_name):
    """_summary_

    Fonction qui sauvegarde le fichier .qmd depuis qgis dans le répertoire temporaire.

    Args:
        layer_name (string): nom de la couche
    Returns:
        fichier qmd : fichier qmd généré par Qgis contenant les metadata
    """
    layer = QgsProject.instance().mapLayersByName(layer_name)
    Qmd_file = temp_file + "/" + layer_name + ".qmd"
    layer[0].saveNamedMetadata(Qmd_file)
    return Qmd_file


def transform_QMD_TO_XML(layer_name):
    """_summary_

    Fonction qui va traduire le fichier .qmd en texte xml (car le qmd n'est pas lisible par geonetwork).

    Args:
        layer_name (str): nom de la couche
    Returns:
        str : génére le code xml qui correspond au fichier qmd
    """
    input_Qmd_file = saveTempQmd(layer_name)
    xslt_file = ISO_file_path + "/qgis-to-iso19139.xsl"
    in_dom = lxml.parse(input_Qmd_file)
    xslt = lxml.parse(xslt_file)
    transform = lxml.XSLT(xslt)
    out_dom = transform(in_dom)
    s = (
        '<?xml version="1.0" encoding="UTF-8"?>\n'
        + lxml.tostring(out_dom, pretty_print=True).decode()
    )
    dom = minidom.parseString(s)
    return dom.toprettyxml(indent="  ")


def addThumbnail(uuid, layer_name):
    """_summary_

    Fonction qui  créer une image de taille 800x800 pixels de l'étendu spatiale des données en question avec un arrière-plan blanc.

    Args:
        uuid (str): code unique identifiant une fiche de metadata
        layer_name (str): nom de la couche
    """
    temp_folder = temp_file
    # créer l'image
    img = QImage(QSize(800, 800), QImage.Format_ARGB32_Premultiplied)
    # définir la couleur de l'arriére plan (Blanc)
    color = QColor(255, 255, 255, 255)
    img.fill(color.rgba())
    # créer le painter
    p = QPainter()
    p.begin(img)
    p.setRenderHint(QPainter.Antialiasing)
    # créer les paramétres de la carte
    ms = QgsMapSettings()
    ms.setBackgroundColor(color)
    # set layers to render
    layer = QgsProject.instance().mapLayersByName(layer_name)
    ms.setLayers([layer[0]])
    # définir l'étendu spatiale
    rect = QgsRectangle(ms.fullExtent())
    rect.scale(1.1)
    ms.setExtent(rect)
    # définir la taille de l'image
    ms.setOutputSize(img.size())
    # setup le rendu de la carte
    render = QgsMapRendererCustomPainterJob(ms, p)
    render.start()
    render.waitForFinished()
    p.end()
    # sauvegarder l'image
    img.save(temp_folder + "/" + uuid + ".png")


def addSubElement(parent, tag, value=None, attrib=None):
    """_summary_

    Fonction qui définit les parents/enfants dans un fichier xml.

    Args:
        parent (str): l'élément parent auquel l'élément enfant sera ajouté.
        tag (str): la balise XML à utiliser pour créer l'élément enfant.
        value (str, optional):  la valeur de texte à assigner à l'élément enfant. Defaults to None.
        attrib (dict, optional): les attributs à assigner à l'élément enfant. Defaults to None.

    Returns:
        Element: l'élément enfant créé.
    """
    sub = SubElement(parent, tag, attrib=attrib or {})
    if value is not None:
        sub.text = value
    return sub


def createInfoXml(uuid, thumb_filename):
    """_summary_

    Cette fonction créer le fichier info.xml qui contient des infromations nécessaires au fichier zip de metadata.

    Args:
        uuid (str): code unique identifiant une fiche de metadata.
        thumb_filename (str): une chaîne de caractères qui représente le nom du fichier image miniature.

    Returns:
        str: code xml.
    """
    root = Element("info", {"version": "1.1"})
    general = addSubElement(root, "general")
    d = datetime.now().isoformat()
    addSubElement(general, "changeDate", d)
    addSubElement(general, "createDate", d)
    addSubElement(general, "schema", "iso19139")
    addSubElement(general, "isTemplate", "n")
    addSubElement(general, "format", "full")
    addSubElement(general, "localId")
    addSubElement(general, "uuid", uuid)
    addSubElement(general, "siteId", "site_test")
    addSubElement(general, "siteName", "site_name_test")
    addSubElement(root, "categories", attrib={"name": "photo"})
    privs = addSubElement(root, "privileges")
    grp = addSubElement(privs, "group", attrib={"name": "all"})
    addSubElement(grp, "operation", attrib={"name": "dynamic"})
    addSubElement(grp, "operation", attrib={"name": "featured"})
    addSubElement(grp, "operation", attrib={"name": "view"})
    addSubElement(grp, "operation", attrib={"name": "download"})
    public = addSubElement(root, "public")
    addSubElement(
        public,
        "file",
        attrib={"name": os.path.basename(thumb_filename), "changeDate": d},
    )
    addSubElement(root, "private")
    xmlstring = ElementTree.tostring(root, encoding="UTF-8", method="xml").decode()
    dom = minidom.parseString(xmlstring)
    return dom.toprettyxml(indent="  ")


def createZip(
    layer_name, uuid, INSPIRE_keywords, LayerType, LayerDenominateur, DatePublication
):
    """_summary_

    Cette fonction permet de créer le fichier zip contenant les fichiers xml et images sous un format lisible par geonetwork.

    Args:
        layer_name (str): nom de la couche.
        uuid (str): code unique identifiant une fiche de metadata.
        INSPIRE_keywords (str): une liste de chaînes de caractères représentant les mots-clés INSPIRE associés à la couche.
    """
    thumb_filename = temp_file + "/" + uuid + ".png"
    zip_filename = temp_file + "/" + uuid + ".zip"
    addThumbnail(uuid, layer_name)
    z = zipfile.ZipFile(zip_filename, "w")
    meta_xml = transform_QMD_TO_XML(layer_name)
    if INSPIRE_keywords:
        meta_xml = insertINSPIRExml(meta_xml, INSPIRE_keywords)
    meta_xml = insertLayerType(meta_xml, LayerType)
    meta_xml = insertLayerDenominateur(meta_xml, LayerDenominateur)
    meta_xml = updateFileIdentifier(meta_xml, uuid)
    meta_xml = insertContactXml(meta_xml)
    if DatePublication != None:
        meta_xml = insertDatePublication(meta_xml, DatePublication)
    z.writestr(os.path.join(uuid, os.path.join("metadata", "metadata.xml")), meta_xml)
    z.write(
        thumb_filename, os.path.join(uuid, "public", os.path.basename(thumb_filename))
    )
    z.writestr(os.path.join(uuid, os.path.join("private", "")), "")
    info = createInfoXml(uuid, thumb_filename)
    z.writestr(os.path.join(uuid, "info.xml"), info)
    z.close()


def cleanTemp():
    """_summary_

    Cette fonction permet de supprimer tous les fichiers et dossiers du répertoire temporaire (variable temp_file) sauf les fichiers zip et le fichier cookie.txt.
    """
    for filename in os.listdir(temp_file):
        if filename.endswith(".zip") or filename == "cookie.txt":
            continue
        file_path = os.path.join(temp_file, filename)
        if os.path.isfile(file_path) or os.path.islink(file_path):
            os.unlink(file_path)
        elif os.path.isdir(file_path):
            shutil.rmtree(file_path)
            """         except Exception as e:
            print('Pas possible de supprimer %s. Raison: %s' % (file_path, e)) """


def removeAllZipFiles():
    """_summary_

    Cette fonction permet de supprimer tous les fichiers zip du fichier temporaire.
    """
    for filename in os.listdir(temp_file):
        if filename.endswith(".zip"):
            file_path = os.path.join(temp_file, filename)
            os.unlink(file_path)


def insertINSPIRExml(xml_string, keywords):
    """_summary_

    Cette fonction renvoie une chaîne de caractères représentant le document XML mis à jour avec les mots-clés INSPIRE ajoutés, formatée avec une indentation pour une meilleure lisibilité.

    Args:
        xml_string (str): une chaîne de caractères représentant un document XML contenant des métadonnées.
        keywords (str): une liste de chaînes de caractères représentant les mots-clés INSPIRE à ajouter aux métadonnées.

    Returns:
        str : code xml.
    """
    tree = ET.fromstring(xml_string)
    root = tree

    namespaces = {
        "gmd": "http://www.isotc211.org/2005/gmd",
        "gco": "http://www.isotc211.org/2005/gco",
    }

    ET.register_namespace("gmd", "http://www.isotc211.org/2005/gmd")
    ET.register_namespace("gco", "http://www.isotc211.org/2005/gco")
    key = "{http://www.isotc211.org/2005/gmd}descriptiveKeywords"
    descriptive_keywords = [
        el
        for el in root.findall(".//" + key, namespaces)
        if el.attrib.get("id") == "INSPIRE"
    ]

    if descriptive_keywords:
        descriptive_keyword = descriptive_keywords[0]
        md_keywords = descriptive_keyword.find("./gmd:MD_Keywords", namespaces)

        for keyword in keywords:
            gmd_keyword = ET.SubElement(md_keywords, "gmd:keyword")
            gco_string = ET.SubElement(gmd_keyword, "gco:CharacterString")
            gco_string.text = keyword

        xml_string = ET.tostring(root, encoding="utf-8", method="xml")
    return xml.dom.minidom.parseString(xml_string).toprettyxml(indent="  ")


def insertLayerType(xml_string, LayerType):
    """_summary_

    Cette fonction renvoie une chaîne de caractères représentant le document XML mis à jour avec le type de la couche, formatée avec une indentation pour une meilleure lisibilité.

    Args:
        xml_string (str): une chaîne de caractères représentant un document XML contenant des métadonnées.
        LayerType (str): chaîne de caractères représentant le type de la couche.

    Returns:
        str : code xml.
    """
    tree = ET.fromstring(xml_string)
    root = tree

    namespaces = {
        "gmd": "http://www.isotc211.org/2005/gmd",
        "gco": "http://www.isotc211.org/2005/gco",
    }

    ET.register_namespace("gmd", "http://www.isotc211.org/2005/gmd")
    ET.register_namespace("gco", "http://www.isotc211.org/2005/gco")
    key = "{http://www.isotc211.org/2005/gmd}spatialRepresentationType"
    spatial_representation_types_code = [
        el
        for el in root.findall(".//" + key, namespaces)
        if el.find("./gmd:MD_SpatialRepresentationTypeCode", namespaces).attrib.get(
            "codeList"
        )
        == "http://standards.iso.org/iso/19139/resources/gmxCodelists.xml#MD_SpatialRepresentationTypeCode"
    ]

    if spatial_representation_types_code:
        md_spatial_representation_type_code = spatial_representation_types_code[0].find(
            "./gmd:MD_SpatialRepresentationTypeCode", namespaces
        )
        md_spatial_representation_type_code.attrib["codeListValue"] = LayerType

        xml_string = ET.tostring(root, encoding="utf-8", method="xml")
    return xml.dom.minidom.parseString(xml_string).toprettyxml(indent="  ")


def insertLayerDenominateur(xml_string, LayerDenominateur):
    """_summary_

    Cette fonction renvoie une chaîne de caractères représentant le document XML mis à jour avec le LayerDenominateur inséré entre les balises appropriées, formaté avec une indentation pour une meilleure lisibilité.

    Args:
        xml_string (str): une chaîne de caractères représentant un document XML contenant des métadonnées.
        LayerDenominateur (str): chaîne de caractères représentant la valeur à insérer dans les balises <gco:Integer></gco:Integer>.

    Returns:
        str : code xml.
    """
    tree = ET.fromstring(xml_string)
    root = tree

    namespaces = {
        "gmd": "http://www.isotc211.org/2005/gmd",
        "gco": "http://www.isotc211.org/2005/gco",
    }

    ET.register_namespace("gmd", "http://www.isotc211.org/2005/gmd")
    ET.register_namespace("gco", "http://www.isotc211.org/2005/gco")

    key = "{http://www.isotc211.org/2005/gmd}denominator"
    denominators = root.findall(".//" + key, namespaces)

    for denominator in denominators:
        integer_element = denominator.find("./gco:Integer", namespaces)
        if integer_element is not None:
            integer_element.text = str(LayerDenominateur)

    xml_string = ET.tostring(root, encoding="utf-8", method="xml")

    return xml.dom.minidom.parseString(xml_string).toprettyxml(indent="  ")


def insertDatePublication(xml_string, DatePublication):
    """Insère la valeur DatePublication entre les balises <gco:Date></gco:Date> du document XML.

    Args:
        xml_string (str): Une chaîne de caractères représentant un document XML contenant des métadonnées.
        DatePublication (str): La valeur à insérer dans les balises <gco:Date></gco:Date>.

    Returns:
        str: Le document XML mis à jour avec DatePublication, formaté avec une indentation.
    """
    tree = ET.fromstring(xml_string)
    root = tree

    namespaces = {
        "gmd": "http://www.isotc211.org/2005/gmd",
        "gco": "http://www.isotc211.org/2005/gco",
    }

    ET.register_namespace("gmd", "http://www.isotc211.org/2005/gmd")
    ET.register_namespace("gco", "http://www.isotc211.org/2005/gco")

    key = "{http://www.isotc211.org/2005/gco}Date"
    date_elements = root.findall(
        ".//gmd:date/gmd:CI_Date/gmd:date/gco:Date", namespaces
    )

    for date_element in date_elements:
        date_element.text = str(DatePublication)

    xml_string = ET.tostring(root, encoding="utf-8", method="xml")
    xml_formatted = xml_string.decode()

    return xml_formatted


def updateFileIdentifier(xml_string, MetaID):
    """Cette fonction renvoie une chaîne de caractères représentant le document XML mis à jour l'identifiant de la fiche au lieu de celui de la table.

    Args:
        xml_string (str): une chaîne de caractères représentant un document XML contenant des métadonnées.
        MetaID (str): chaîne de caractères représentant l'identifiant de la fiche.

    Returns:
        str : code xml.
    """
    tree = ET.fromstring(xml_string)
    namespaces = {
        "gmd": "http://www.isotc211.org/2005/gmd",
        "gco": "http://www.isotc211.org/2005/gco",
    }

    file_identifier_element = tree.find(
        ".//gmd:fileIdentifier/gco:CharacterString", namespaces
    )

    if file_identifier_element is not None:
        file_identifier_element.text = MetaID

    file_name_element = tree.find(".//gmd:fileName/gco:CharacterString", namespaces)

    if file_name_element is not None:
        file_name_element.text = MetaID + ".png"

    updated_xml_string = ET.tostring(tree, encoding="utf-8", method="xml")
    prettified_xml_string = xml.dom.minidom.parseString(updated_xml_string).toprettyxml(
        indent="  "
    )

    return prettified_xml_string


def insertContactXml(xml_string):
    """Cette fonction renvoie une chaîne de caractères représentant le document XML mis à jour avec le contact de la métropole.

    Args:
        xml_string (str): une chaîne de caractères représentant un document XML contenant des métadonnées.

    Returns:
        str: code xml.
    """
    tree = ET.fromstring(xml_string)
    root = tree

    namespaces = {
        "gmd": "http://www.isotc211.org/2005/gmd",
        "gco": "http://www.isotc211.org/2005/gco",
    }

    ET.register_namespace("gmd", "http://www.isotc211.org/2005/gmd")
    ET.register_namespace("gco", "http://www.isotc211.org/2005/gco")

    point_of_contact = root.find(".//gmd:pointOfContact", namespaces)
    descriptive_keywords_parent = root.find(
        ".//gmd:descriptiveKeywords[@id='INSPIRE']/..", namespaces
    )
    if point_of_contact is not None and descriptive_keywords_parent is not None:
        # Créer un élément à partir du bloc XML à insérer
        new_element = ET.fromstring(new_xml_block)

        # Insérer le nouvel élément entre les balises </gmd:pointOfContact> et <gmd:descriptiveKeywords id="INSPIRE">
        index = list(descriptive_keywords_parent).index(point_of_contact) + 1
        descriptive_keywords_parent.insert(index, new_element)

    xml_string = ET.tostring(root, encoding="utf-8", method="xml")
    return xml.dom.minidom.parseString(xml_string).toprettyxml(indent="  ")
