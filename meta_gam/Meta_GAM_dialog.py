# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MetaGAMDialog
                                 A QGIS plugin
 Plugin qui permet de gérer les métadonnées uniques à la métropole de Grenoble.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-20
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Service SIT - Amr HAMADEH
        email                : demande_sit@grenoblealpesmetropole.fr
 ***************************************************************************/

/***************************************************************************
 *                               h                                          *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

### Importer les bibliotheques nécessaires
import os
from qgis.core import QgsProject
from qgis.core import *
import re
import requests
from PyQt5 import QtWidgets, uic
from PyQt5.QtGui import (
    QStandardItemModel,
    QStandardItem,
    QBrush,
    QColor,
    QDesktopServices,
)
from PyQt5 import QtWidgets
from qgis.PyQt import *
from qgis.PyQt import QtWidgets, QtCore
from qgis.PyQt.QtWidgets import *
from qgis.gui import QgsCheckableComboBox
from qgis.PyQt.QtCore import Qt
from .Meta_GAM_Geonetwork import connexionGeonetwork, postMetaGN, getMetaDateGN
from .Meta_GAM_QMD_XML import createZip, cleanTemp, removeAllZipFiles
from PyQt5.QtCore import QUrl
from PyQt5.QtWidgets import QDialog, QLabel, QLineEdit, QPushButton, QVBoxLayout
import psycopg2
import json
from qgis.core import QgsProject, QgsDataSourceUri
from qgis.core import (
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsRectangle,
    QgsBox3d,
)

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "Meta_GAM_dialog_base.ui")
)


class MetaGAMDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(MetaGAMDialog, self).__init__(parent)
        self.setupUi(self)
        self.treeWidget = self.findChild(QtWidgets.QTreeWidget, "treeWidget")
        self.tableGN = self.findChild(QtWidgets.QTableView, "tableGN")
        self.tableGN.doubleClicked.connect(self.onTableGNDoubleClick)
        self.layers_niveau = (
            {}
        )  # Dictionnaire pour stocker le nom de la couche et son niveau par rapport à la thématique
        self.dict_cat_iso = {
            "Agriculture": "farming",
            "Biote": "biota",
            "Limites": "boundaries",
            "Climatologie/Météorologie/Atmoshpère": "climatologyMeteorologyAtmosphere",
            "Economie": "economy",
            "Altitude": "elevation",
            "Environnement": "environment",
            "Informations géoscientifiques": "geoscientificInformation",
            "Santé": "health",
            "Imagerie/Cartes de base/Occupation des terres": "imageryBaseMapsEarthCover",
            "Renseignement/Secteur militaire": "intelligenceMilitary",
            "Eaux intérieures": "inlandWaters",
            "Localisation": "location",
            "Océans": "oceans",
            "Planification/Cadastre": "planningCadastre",
            "Société": "society",
            "Structure": "structure",
            "Transport": "transportation",
            "Services d'utilité publique/Communication": "utilitiesCommunication",
        }
        self.UserPassword = None
        self.pbPost.setVisible(False)
        self.label_3.setVisible(False)
        self.frame_legende.setVisible(False)
        self.label_Green.setStyleSheet("color: green;")
        self.label_Red.setStyleSheet("color: red;")
        self.label_Orange.setStyleSheet("color: orange;")
        self.tree_checkbox_status = None
        self.labelGeo.setOpenExternalLinks(True)
        self.pbAutoMeta.clicked.connect(self.AutoFillMeta)
        self.pb_meta_cancel.clicked.connect(self.PluginClose)
        self.pb_meta_apply.clicked.connect(self.get_tree_checkbox_status)
        self.pb_meta_apply.clicked.connect(self.UpdateMeta)
        self.pb_meta_apply.clicked.connect(self.treeLayersColor)
        self.pb_meta_apply.clicked.connect(self.set_tree_checkbox_status)
        self.pbConnexion.clicked.connect(self.checkConnexionGN)
        self.pbPost.clicked.connect(self.updateProgressBar)
        self.pbCancel.clicked.connect(self.PluginClose)

    def ConnexionPostgresqlPassword(self):
        # Créer une instance de QDialog
        dialog = QDialog()

        # Créer un label et un champ de texte
        label = QLabel("Veuillez saisir uniquement votre mot de passe:")
        password_edit = QLineEdit()
        password_edit.setEchoMode(QLineEdit.Password)  # Masquer les caractères saisis

        # Créer un bouton OK
        ok_button = QPushButton("OK")
        ok_button.clicked.connect(
            dialog.accept
        )  # Fermer la fenêtre et renvoyer QDialog.Accepted

        # Créer un layout vertical et ajouter les widgets
        layout = QVBoxLayout(dialog)
        layout.addWidget(label)
        layout.addWidget(password_edit)
        layout.addWidget(ok_button)
        dialog.setWindowTitle("Saisie du mot de passe")
        # Afficher la fenêtre modale et renvoyer la valeur saisie par l'utilisateur
        if dialog.exec_() == QDialog.Accepted:
            self.UserPassword = password_edit.text()
            if self.ConnexionPostgresql()[0]:
                # La connexion a réussi
                return True
            else:
                return self.ConnexionPostgresqlPassword()

    def ConnexionPostgresql(self):
        try:
            connexion = psycopg2.connect(service="bd_prod", password=self.UserPassword)
            return True, connexion
        except psycopg2.Error as e:
            QMessageBox.critical(self, "Erreur", str(e), QMessageBox.Ok)
            return False, None

    def getMetadataGestionTab(self):
        connexion = self.ConnexionPostgresql()[1]
        cur = connexion.cursor()
        cur.execute("SELECT * FROM sit_hydre.v_liste_nom_schema_objet")
        rows = cur.fetchall()
        columns = [desc[0] for desc in cur.description]
        json = []
        for row in rows:
            json.append(dict(zip(columns, row)))
        return json

    def getMetadataTab(self):
        connexion = self.ConnexionPostgresql()[1]
        cur = connexion.cursor()
        cur.execute("SELECT * FROM sit_hydre.gest_bdd_rel_objets_thematique")
        rows = cur.fetchall()
        columns = [desc[0] for desc in cur.description]
        json = []
        for row in rows:
            json.append(dict(zip(columns, row)))
        return json

    def getContactTab(self):
        connexion = self.ConnexionPostgresql()[1]
        cur = connexion.cursor()
        cur.execute("SELECT * FROM sit_hydre.gest_bdd_contact_referents")
        rows = cur.fetchall()
        columns = [desc[0] for desc in cur.description]
        json = []
        for row in rows:
            json.append(dict(zip(columns, row)))
        return json

    def getThematiqueTab(self):
        connexion = self.ConnexionPostgresql()[1]
        cur = connexion.cursor()
        cur.execute("SELECT * FROM sit_hydre.gest_bdd_thematique")
        rows = cur.fetchall()
        columns = [desc[0] for desc in cur.description]
        json = []
        for row in rows:
            json.append(dict(zip(columns, row)))
        return json

    def getContactID(self, id_thematique):
        connexion = self.ConnexionPostgresql()[1]
        cur = connexion.cursor()
        cur.execute(
            "SELECT contact_referent_id FROM sit_hydre.gest_bdd_rel_thematique_contact_referents WHERE thematique_id = %s",
            (id_thematique,),
        )
        rows = cur.fetchall()
        contact_ids = [row[0] for row in rows]
        return contact_ids

    def getMetaID(self, id_objet):
        # print('id_objet : ' + id_objet)
        if id_objet:
            connexion = self.ConnexionPostgresql()[1]
            cur = connexion.cursor()
            cur.execute(
                "SELECT metadonnees_id FROM sit_hydre.gest_bdd_rel_objets_thematique WHERE objet_id = %s",
                (id_objet,),
            )
            rows = cur.fetchall()
            # print (rows)
            MetaID = [row[0] for row in rows]
            return MetaID
        return None

    def AutoFillMeta(self):
        """_summary_

        Cette fonction a pour objectif de remplir automatiquement les métadonnées d'une couche dans QGIS. Tout d'abord, elle récupère une couche de contacts à partir de laquelle elle extrait les informations nécessaires pour remplir la partie "contact" des métadonnées de la couche en question. Ensuite, elle récupère l'emprise spatiale de la couche et remplit cette information dans la fiche de métadonnées. Et c'est pareil pour les autres informations de la fiche metadata.

        """
        if self.ConnexionPostgresqlPassword():
            tab_gestion = self.getMetadataGestionTab()
            tab_metadata = self.getMetadataTab()
            tab_contacts = self.getContactTab()
            tab_thematique = self.getThematiqueTab()
            ## On commence à remplir la fiche des metadonnées
            project = QgsProject.instance()
            for (
                layer
            ) in (
                project.mapLayers().values()
            ):  # On parcours les couches du projets une aprés l'autre
                layer_meta = layer.metadata()  # On récupere la fiche de metadata
                # Recuperer nom du schema de la couche
                uri = QgsDataSourceUri(layer.dataProvider().dataSourceUri())
                layer_schema = uri.schema()
                layer_name = uri.table()
                layer_projet_name = layer.name()
                # On récupere l'emprise spataile
                extent = layer.extent()
                xmin = extent.xMinimum()
                xmax = extent.xMaximum()
                ymin = extent.yMinimum()
                ymax = extent.yMaximum()
                # On remplie l'identifiant et on récupére les infos des métadonnées (categories, motsclés, INSPIRE)
                categories = layer_meta.categories()
                keywords = layer_meta.keywords()
                identif = layer_meta.identifier()
                contact_prenom = None
                contact_nom = None
                contact_mail = None
                Licence = None
                Meta_titre = None
                thematique_description = None
                for obj in tab_gestion:
                    id_objet = obj.get("id_objet")
                    nom_objet = obj.get("nom_objet")
                    nom_schema = obj.get("nom_schema")
                    if nom_objet == layer_name and nom_schema == layer_schema:
                        identif = id_objet
                for obj_meta in tab_metadata:
                    id_objet_meta = obj_meta.get("objet_id")
                    if identif == id_objet_meta:
                        niv_thematique = obj_meta.get("niveau")
                        if niv_thematique == 1:
                            self.layers_niveau[layer.name()] = niv_thematique
                            Licence = obj_meta.get("metadonnees")["licences"]
                            categories = obj_meta.get("metadonnees")["categories"]
                            keywords = obj_meta.get("metadonnees")["mots_clefs"]
                            obj_meta.get("metadonnees")["themes_inspire"]
                            Description = obj_meta.get("metadonnees_commentaire")
                            id_thematique = obj_meta.get("thematique_id")
                            Meta_titre = obj_meta.get("metadonnees_titre")
                            contact_id = self.getContactID(id_thematique)
                            for obj_them in tab_thematique:
                                id_objet_them = obj_them.get("id")
                                if id_objet_them == id_thematique:
                                    theme_categories = obj_them.get("metadonnees")[
                                        "categories"
                                    ]
                                    theme_keywords = obj_them.get("metadonnees")[
                                        "mots_clefs"
                                    ]
                                    thematique_description = obj_them.get("description")
                            if categories is not None and theme_categories is not None:
                                # Remplacer les éléments de theme_categories par leurs correspondances
                                for i in range(len(theme_categories)):
                                    if theme_categories[i] in self.dict_cat_iso:
                                        theme_categories[i] = self.dict_cat_iso[
                                            theme_categories[i]
                                        ]
                                theme_categories.extend(categories)
                                categories = theme_categories
                            elif categories is None and theme_categories is not None:
                                categories = theme_categories
                            if keywords is not None and theme_keywords is not None:
                                if isinstance(theme_keywords, str):
                                    theme_keywords = [theme_keywords]
                                for keyword in theme_keywords:
                                    if keyword not in keywords:
                                        keywords.insert(0, keyword)
                            elif keywords is None and theme_keywords is not None:
                                keywords = theme_keywords
                            for obj_contact in tab_contacts:
                                if contact_id != []:
                                    if contact_id[0] == obj_contact.get("id"):
                                        contact_nom = obj_contact.get("nom")
                                        contact_prenom = obj_contact.get("prenom")
                                        contact_mail = obj_contact.get("mail")
                if len(self.layers_niveau) > 0:
                    if self.layers_niveau.get(layer_projet_name) == 1:
                        meta_contact = QgsLayerMetadata.Contact()
                        if contact_nom != None:
                            meta_contact.name = contact_prenom + " " + contact_nom
                            meta_contact.organization = "Grenoble Alpes Métropole"
                            meta_contact.email = contact_mail
                            meta_contact.role = "custodian"
                            address = QgsLayerMetadata.Address()
                            # address.type = 'postal'
                            address.address = "3 Rue Malakoff"
                            address.city = "Grenoble"
                            # address.administrativeArea = 'anyprovince'
                            address.postalCode = "38100"
                            # address.country = 'France'
                            meta_contact.addresses = [address]

                        # On remplie la partie Résumé
                        res = None
                        if (
                            layer.type() != QgsMapLayerType.RasterLayer
                            or layer.type() != QgsMapLayerType.TileLayer
                        ):
                            titre = "Liste des commentaires des colonnes:"
                            com_col = ""
                            titre_2 = "Résumé de la couche:"
                            com_lay = layer.metadata().abstract()
                            if com_lay is None:
                                com_lay = Description
                            if (
                                titre_2 in com_lay
                            ):  # ce morceau corresponds à la mise à jour du résumé uniquement en cas de change dans la base mais aussi evite les doublons
                                start = titre_2
                                end = titre
                                com_lay = (com_lay.split(start))[1].split(end)[0]
                                com_lay = com_lay.strip()
                            for entite in layer.fields():
                                if (
                                    len(entite.comment()) != 0
                                    and len(entite.alias()) != 0
                                ):
                                    com_col = (
                                        com_col
                                        + "\n"
                                        + (
                                            "- "
                                            + entite.name().capitalize()
                                            + " ("
                                            + entite.alias()
                                            + ")"
                                            + ": "
                                            + entite.comment().capitalize()
                                        )
                                    )
                                elif (
                                    len(entite.comment()) != 0
                                    and len(entite.alias()) == 0
                                ):
                                    com_col = (
                                        com_col
                                        + "\n"
                                        + (
                                            "- "
                                            + entite.name().capitalize()
                                            + ": "
                                            + entite.comment().capitalize()
                                        )
                                    )
                                elif (
                                    len(entite.comment()) == 0
                                    and len(entite.alias()) != 0
                                ):
                                    com_col = (
                                        com_col
                                        + "\n"
                                        + (
                                            "- "
                                            + entite.name().capitalize()
                                            + " ("
                                            + entite.alias()
                                            + ")"
                                        )
                                    )
                                com_col = com_col.replace("(", "[").replace(")", "]")
                            if len(com_col) != 0 and len(com_lay) != 0:
                                if titre in com_lay and titre_2 not in com_lay:
                                    res = titre + "\n" + com_col
                                else:
                                    res = (
                                        titre_2
                                        + "\n"
                                        + "\n"
                                        + com_lay
                                        + "\n"
                                        + "\n"
                                        + titre
                                        + "\n"
                                        + com_col
                                    )
                            elif len(com_lay) == 0 and len(com_col) != 0:
                                res = titre + "\n" + com_col
                            elif len(com_lay) != 0 and len(com_col) == 0:
                                res = com_lay
                            elif len(com_col) == 0 and len(com_lay) == 0:
                                res = ""

                            # On ajoute le résumé de la thématique
                            titre_res_theme = "Résumé sur la thématique:"
                            if (
                                thematique_description is not None
                                and titre_res_theme not in res
                            ):
                                res = (
                                    titre_res_theme
                                    + "\n"
                                    + thematique_description
                                    + "\n"
                                    + "\n"
                                    + res
                                )
                            elif (
                                thematique_description is not None
                                and titre_res_theme in res
                            ):
                                searche_theme = re.search(
                                    rf"{titre_res_theme}\s*(.*?)\s*$",
                                    res,
                                    re.DOTALL | re.MULTILINE,
                                )
                                if searche_theme:
                                    texte_extrait = searche_theme.group(1)
                                    if texte_extrait != thematique_description:
                                        res = res.replace(
                                            texte_extrait, thematique_description
                                        )

                        # On remplie le Titre
                        title = layer_meta.title()
                        if Meta_titre is not None:
                            title = Meta_titre

                        # On remplie la partie Liens
                        link_metro = QgsAbstractMetadataBase.Link()
                        link_metro.name = "Grenoble-Alpes Métropole"
                        link_metro.type = "https"
                        link_metro.description = "Site de la Métropole"
                        link_metro.url = " https://www.grenoblealpesmetropole.fr/"
                        link_metro.format = "HTTPS"

                        list_links = [link_metro]
                        if (
                            layer_meta.licenses() != []
                            and layer_meta.licenses()[0] == "Licence ouverte (OpenDATA)"
                        ):
                            link_wms = QgsAbstractMetadataBase.Link()
                            link_wms.name = layer_name
                            link_wms.type = "OGC-WMS Capabilities service (ver 1.3.0)"
                            link_wms.description = layer_name
                            link_wms.url = (
                                "https://geoflux.grenoblealpesmetropole.fr/geoserver/"
                                + layer_schema
                                + "/ows?SERVICE=WMS&"
                            )
                            link_wms.format = "WMS"

                            link_kml = QgsAbstractMetadataBase.Link()
                            link_kml.name = "Format KML"
                            link_kml.type = "WWW:DOWNLOAD-1.0-http--download"
                            link_kml.description = layer_name
                            link_kml.url = (
                                "https://geoflux.grenoblealpesmetropole.fr/geoserver/"
                                + layer_schema
                                + "/ows?service=WFS&version=1.0.0&request=GetFeature&typeName="
                                + layer_schema
                                + "%3A"
                                + layer.name()
                                + "&outputFormat=kml"
                            )
                            link_kml.format = "KML"

                            link_geojson = QgsAbstractMetadataBase.Link()
                            link_geojson.name = "Format Geojson"
                            link_geojson.type = "WWW:DOWNLOAD-1.0-http--download"
                            link_geojson.description = layer_name
                            link_geojson.url = (
                                "https://geoflux.grenoblealpesmetropole.fr/geoserver/"
                                + layer_schema
                                + "/ows?service=WFS&version=1.0.0&request=GetFeature&typeName="
                                + layer_schema
                                + "%3A"
                                + layer.name()
                                + "&outputFormat=application%2Fjson"
                            )
                            link_geojson.format = "GeoJSON"
                            params_WMS = {
                                "request": "GetCapabilities",
                                "service": "WMS",
                            }
                            response_wms = requests.get(link_wms.url, params=params_WMS)
                            response_kml = requests.get(link_kml.url)
                            response_geojson = requests.get(link_kml.url)
                            if response_kml.status_code == 200:
                                list_links.append(link_kml)
                            if response_geojson.status_code == 200:
                                list_links.append(link_geojson)
                            if response_wms.status_code == 200:
                                list_links.append(link_wms)
                            layer_meta.setLinks(list_links)
                        else:
                            layer_meta.setLinks(list_links)

                        # On remplie la partie Emprise spatiale
                        source_crs = QgsCoordinateReferenceSystem(3945)
                        target_crs = QgsCoordinateReferenceSystem(4326)
                        ext = QgsLayerMetadata.Extent()
                        se = QgsLayerMetadata.SpatialExtent()
                        se.extentCrs = target_crs
                        transform = QgsCoordinateTransform(
                            source_crs, target_crs, QgsProject.instance()
                        )
                        bounds = QgsBox3d(xmin, ymin, 0, xmax, ymax, 0)
                        source_rect = QgsRectangle(
                            bounds.xMinimum(),
                            bounds.yMinimum(),
                            bounds.xMaximum(),
                            bounds.yMaximum(),
                        )
                        target_rect = transform.transform(source_rect)
                        se.bounds = QgsBox3d(
                            target_rect.xMinimum(),
                            target_rect.yMinimum(),
                            0,
                            target_rect.xMaximum(),
                            target_rect.yMaximum(),
                            0,
                        )
                        ext.setSpatialExtents([se])

                        # On remplie la partie Catégories et mots clés
                        if isinstance(keywords, dict):
                            keywords = list(keywords.values())
                        if keywords is not None:
                            if not isinstance(keywords, list):
                                keywords = [keywords]
                            layer_meta.setKeywords({"": keywords})
                        if categories != None:
                            layer_meta.setCategories(categories)
                        # On met à jour les metadonnées
                        layer_meta.setIdentifier(identif)
                        layer_meta.setAbstract(res)
                        layer_meta.setLanguage("FRA")
                        layer_meta.setTitle(title)
                        layer_meta.setContacts([meta_contact])
                        layer_meta.setExtent(ext)
                        if Licence != None:
                            layer_meta.setLicenses([Licence])
                        layer.setMetadata(layer_meta)
                    self.MetaMessage()
                    # self.activateWindow() # pour remettre la page du plugin en premier plan
                    self.LayersTree()
                    self.setTree()
                    self.treeLayersColor()
                    self.frame_legende.setVisible(True)
                else:
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Critical)
                    msg.setText(
                        "Aucune couche dans votre projet est une couche principale!"
                    )
                    msg.setWindowTitle("Erreur")
                    msg.exec_()

    def MetaMessage(self):
        """_summary_

        Fonction qui renvoie aprés l'auto-remplissage des métadonnées.

        """
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setText("Les fiches métadonnées sont remplies!")
        msg.setWindowTitle("Information metadata")
        # msg.exec_()

    def MetaQgisValidation(self, layer_name):
        """_summary_

        Cette fonction effectue une validation de la métadonnée pour une couche à l'aide de la classe QgsNativeMetadataValidator de QGIS. La méthode (QgsNativeMetadataValidator) retourne une liste de résultats de validation, et la première valeur de cette liste est renvoyée en sortie de fonction.

        Args:
            layer_name (str): nom de la couche.
        """
        layer = QgsProject.instance().mapLayersByName(layer_name)
        meta = layer[0].metadata()
        validator = QgsNativeMetadataValidator()
        validation = validator.validate(meta)
        return validation[0]

    def PluginClose(self):
        """_summary_

        Fonction qui ferme le plugin.

        """
        self.close()

    def LayersTree(self):
        """_summary_

        Cette fonction serre à structure l'arbre du plugin (le tableau qui affiche toutes les informations sur les métadonnées).
        Sans remplir d'information elle définit uniquement sa squelette.

        """
        # list_licenses = ["","Licence Ouverte version 2.0","ODC Open Database License (ODbL) version 1.0","Apache License 2.0","BSD 2-Clause (Simplified) License","BSD 3-Clause (New) or (Revised) License","CeCILL-B Free Software License Agreement","MIT License","CeCILL Free Software License Agreement v2.1","CeCILL-C Free Software License Agreement","GNU General Public License v3.0 or later","GNU Lesser General Public License v3.0 or later","GNU Affero General Public License v3.0 or later","Mozilla Public License 2.0","Eclipse Public License 2.0","European Union Public License 1.2"]
        list_licenses = [
            "",
            "Licence ouverte (OpenDATA)",
            "Licence fermée (Uniquement en interne)",
        ]

        list_themes_inspire = [
            "Altitude",
            "Occupation des terres",
            "Ortho-imagerie",
            "Géologie",
            "Unités statistiques",
            "Installations de suivi environnemental",
            "Bâtiments",
            "Sols",
            "Usage des sols",
            "Santé et sécurité des personnes",
            "Services d'utilité publique et services publics",
            "Lieux de production et sites industriels",
            "Installations agricoles et aquacoles",
            "Répartition de la population — démographie",
            "Zones de gestion, de restriction ou de réglementation et unités de déclaration",
            "Zones à risque naturel",
            "Conditions atmosphériques",
            "Caractéristiques géographiques océanographiques",
            "Régions maritimes",
            "Régions biogéographiques",
            "Habitats et biotopes",
            "Répartition des espèces",
            "Sources d'énergie",
            "Ressources minérales",
            "Référentiels de coordonnées",
            "Systèmes de maillage géographique",
            "Dénominations géographiques",
            "Unités administratives",
            "Adresses",
            "Parcelles cadastrales",
            "Réseaux de transport",
            "Hydrographie",
            "Sites protégés",
            "Caractéristiques géographiques météorologiques",
        ]
        popup_texts = [
            "Modèles numériques pour l'altitude des surfaces terrestres, glaciaires et océaniques. Comprend l'altitude terrestre, la bathymétrie et la ligne de rivage.",
            "Couverture physique et biologique de la surface terrestre, y compris les surfaces artificielles, les zones agricoles, les forêts, les zones (semi-)naturelles, les zones humides et les masses d'eau.",
            "Images géoréférencées de la surface terrestre, provenant de satellites ou de capteurs aéroportés.",
            "Géologie caractérisée en fonction de la composition et de la structure. Englobe le substratum rocheux, les aquifères et la géomorphologie.",
            "Unités de diffusion ou d'utilisation d'autres informations statistiques.",
            "La situation et le fonctionnement des installations de suivi environnemental comprennent l'observation et la mesure des émissions, de l'état du milieu environnemental et d'autres paramètres de l'écosystème (biodiversité, conditions écologiques de la végétation, etc.) par les autorités publiques ou pour leur compte.",
            "Situation géographique des bâtiments.",
            "Sols et sous-sol caractérisés selon leur profondeur, texture, structure et teneur en particules et en matières organiques, pierrosité, érosion, le cas échéant pente moyenne et capacité anticipée de stockage de l'eau.",
            "Territoire caractérisé selon sa dimension fonctionnelle prévue ou son objet socioéconomique actuel et futur (par exemple, résidentiel, industriel, commercial, agricole, forestier, récréatif).",
            "Répartition géographique des pathologies dominantes (allergies, cancers, maladies respiratoires, etc.) liées directement (pollution de l'air, produits chimiques, appauvrissement de la couche d'ozone, bruit, etc.) ou indirectement (alimentation, organismes génétiquement modifiés, etc.) à la qualité de l'environnement, et ensemble des informations relatif à l'effet de celle-ci sur la santé des hommes (marqueurs biologiques, déclin de la fertilité, épidémies) ou leur bien-être (fatigue, stress, etc.).",
            "Comprend les installations d'utilité publique, tels que les égouts ou les réseaux et installations liés à la gestion des déchets, à l'approvisionnement énergétique, à l'approvisionnement en eau, ainsi que les services administratifs et sociaux publics, tels que les administrations publiques, les sites de la protection civile, les écoles et les hôpitaux.",
            "Sites de production industrielle, y compris les installations couvertes par la directive 96/61/CE du Conseil du 24 septembre 1996 relative à la prévention et à la réduction intégrées de la pollution [1] et les installations de captage d'eau, d'extraction minière et de stockage.",
            "Équipement et installations de production agricoles (y compris les systèmes d'irrigation, les serres et les étables).",
            "Répartition géographique des personnes, avec les caractéristiques de population et les niveaux d'activité, regroupées par grille, région, unité administrative ou autre unité analytique.",
            "Zones gérées, réglementées ou utilisées pour les rapports aux niveaux international, européen, national, régional et local. Sont inclus les décharges, les zones restreintes aux alentours des sources d'eau potable, les zones vulnérables aux nitrates, les chenaux réglementés en mer ou les eaux intérieures importantes, les zones destinées à la décharge de déchets, les zones soumises à limitation du bruit, les zones faisant l'objet de permis d'exploration et d'extraction minière, les districts hydrographiques, les unités correspondantes utilisées pour les rapports et les zones de gestion du littoral.",
            "Zones sensibles caractérisées en fonction des risques naturels (tous les phénomènes atmosphériques, hydrologiques, sismiques, volcaniques, ainsi que les feux de friche qui peuvent, en raison de leur situation, de leur gravité et de leur fréquence, nuire gravement à la société), tels qu'inondations, glissements et affaissements de terrain, avalanches, incendies de forêts, tremblements de terre et éruptions volcaniques.",
            "Conditions physiques dans l'atmosphère. Comprend les données géographiques fondées sur des mesures, sur des modèles ou sur une combinaison des deux, ainsi que les lieux de mesure.",
            "Conditions physiques des océans (courants, salinité, hauteur des vagues, etc.).",
            "Conditions physiques des mers et des masses d'eau salée divisées en régions et en sous-régions à caractéristiques communes.",
            "Zones présentant des conditions écologiques relativement homogènes avec des caractéristiques communes.",
            "Zones géographiques ayant des caractéristiques écologiques particulières — conditions, processus, structures et fonctions (de maintien de la vie) — favorables aux organismes qui y vivent. Sont incluses les zones terrestres et aquatiques qui se distinguent par leurs caractéristiques géographiques, abiotiques ou biotiques, qu'elles soient naturelles ou semi-naturelles.",
            "Répartition géographique de l'occurrence des espèces animales et végétales regroupées par grille, région, unité administrative ou autre unité analytique.",
            "Sources d'énergie comprenant les hydrocarbures, l'énergie hydraulique, la bioénergie, l'énergie solaire, l'énergie éolienne, etc., le cas échéant accompagnées d'informations relatives à la profondeur/la hauteur de la source.",
            "Ressources minérales comprenant les minerais métalliques, les minéraux industriels, etc., le cas échéant accompagnées d'informations relatives à la profondeur/la hauteur de la ressource.",
            "Systèmes de référencement unique des informations géographiques dans l'espace sous forme d'une série de coordonnées (x, y, z) et/ou la latitude et la longitude et l'altitude, en se fondant sur un point géodésique horizontal et vertical.",
            "Grille multi-résolution harmonisée avec un point d'origine commun et une localisation ainsi qu'une taille des cellules harmonisées.",
            "Noms de zones, de régions, de localités, de grandes villes, de banlieues, de villes moyennes ou d'implantations, ou tout autre élément géographique ou topographique d'intérêt public ou historique.",
            "Unités d'administration séparées par des limites administratives et délimitant les zones dans lesquelles les États membres détiennent et/ou exercent leurs compétences, aux fins de l'administration locale, régionale et nationale.",
            "Localisation des propriétés fondée sur les identifiants des adresses, habituellement le nom de la rue, le numéro de la maison et le code postal.",
            "Zones définies par les registres cadastraux ou équivalents.",
            "Réseaux routier, ferroviaire, aérien et navigable ainsi que les infrastructures associées. Sont également incluses les correspondances entre les différents réseaux, ainsi que le réseau transeuropéen de transport tel que défini dans la décision no 1692/96/CE du Parlement européen et du Conseil du 23 juillet 1996 sur les orientations communautaires pour le développement du réseau transeuropéen de transport [1] et les révisions futures de cette décision.",
            "Éléments hydrographiques, y compris les zones maritimes ainsi que toutes les autres masses d'eau et les éléments qui y sont liés, y compris les bassins et sous-bassins hydrographiques. Conformes, le cas échéant, aux définitions établies par la directive 2000/60/CE du Parlement européen et du Conseil du 23 octobre 2000 établissant un cadre pour une politique communautaire dans le domaine de l'eau [2] et sous forme de réseaux.",
            "Zone désignée ou gérée dans un cadre législatif international, communautaire ou national en vue d'atteindre des objectifs spécifiques de conservation.",
            "Conditions météorologiques et leur mesure: précipitations, température, évapotranspiration, vitesse et direction du vent.",
        ]

        self.treeWidget.clear()
        tree = self.treeWidget
        tree.setColumnCount(4)
        tree.setHeaderLabels(
            ["Geonetwork", "Couches", "Champs de métadonnées manquants", "A compléter"]
        )
        project = QgsProject.instance()
        for layer in project.mapLayers().values():
            layer_meta = layer.metadata()
            layer_name = layer.name()
            if len(self.layers_niveau) > 0:
                if self.layers_niveau.get(layer_name) == 1:
                    if layer_name != "gest_bdd_metadata":
                        attribut = QTreeWidgetItem(tree)
                        checkbox = QCheckBox()
                        # Ajoutez le QCheckBox à la première colonne de l'élément
                        # attribut.setCheckState(0, Qt.Unchecked)
                        tree.setItemWidget(attribut, 0, checkbox)
                        attribut.setText(1, str(layer_name))

                        # Catégories et Mot clés et Thèmes Inspire
                        item_inspire = QTreeWidgetItem(attribut)
                        item_inspire.setText(2, str("Thèmes INSPIRE"))
                        value_inspire = QgsCheckableComboBox()
                        value_inspire.addItems(list_themes_inspire)
                        attribut.addChild(item_inspire)
                        tree.setItemWidget(item_inspire, 3, value_inspire)
                        for j in range(value_inspire.count()):
                            value_inspire.itemText(j)
                            popup_text = popup_texts[j]
                            value_inspire.setItemData(
                                j, popup_text, QtCore.Qt.ToolTipRole
                            )

                        item_keywords = QTreeWidgetItem(attribut)
                        item_keywords.setText(2, str("Mots-clés"))
                        value_keywords = QLineEdit()
                        value_keywords.setPlaceholderText("Keyword1,Keyword2,Keyword3")
                        attribut.addChild(item_keywords)
                        tree.setItemWidget(item_keywords, 3, value_keywords)

                        item_cat = QTreeWidgetItem(attribut)
                        item_cat.setText(2, str("Catégories"))
                        value_Cat = QgsCheckableComboBox()
                        items_dict_cat_fr = list(self.dict_cat_iso.keys())
                        for item in items_dict_cat_fr:
                            value_Cat.addItem(item)
                        attribut.addChild(item_cat)
                        tree.setItemWidget(item_cat, 3, value_Cat)

                        item_licenses = QTreeWidgetItem(attribut)
                        value_licences = QComboBox()
                        value_licences.addItems(list_licenses)
                        item_licenses.setText(2, str("Licence"))
                        # item_licenses.setForeground(2, QColor(255, 165, 0))
                        attribut.addChild(item_licenses)
                        tree.setItemWidget(item_licenses, 3, value_licences)

                        if not self.MetaQgisValidation(layer_name):
                            if layer_meta.title() == "":
                                item_titre = QTreeWidgetItem(attribut)
                                item_titre.setText(2, str("titre"))
                                item_titre.setForeground(2, QBrush(Qt.red))
                                value_titre = QLineEdit()
                                # value_titre.setObjectName("value_titre"+layer_name)
                                attribut.addChild(item_titre)
                                tree.setItemWidget(item_titre, 3, value_titre)
                            if layer_meta.abstract() == "":
                                item_abstract = QTreeWidgetItem(attribut)
                                item_abstract.setText(2, str("Résumé de la couche"))
                                item_abstract.setForeground(2, QColor(255, 165, 0))
                                value_abstract = QTextEdit()
                                value_abstract.setFixedHeight(80)
                                attribut.addChild(item_abstract)
                                tree.setItemWidget(item_abstract, 3, value_abstract)

    def UpdateMeta(self):
        if self.treeWidget.topLevelItemCount() == 0:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Vous n'avez pas lancer l'Auto-remplissage encore!")
            msg.setWindowTitle("Erreur!!")
            msg.exec_()
        else:
            parent = self.treeWidget.invisibleRootItem()
            project = QgsProject.instance()
            for layer in project.mapLayers().values():
                layer_meta = layer.metadata()
                layer_name = layer.name()
                if len(self.layers_niveau) > 0:
                    if self.layers_niveau.get(layer_name) == 1:
                        source = str(layer.source())
                        start = source.find("table=") + len("table=")
                        end = source.find(".")
                        layer_schema = source[start:end]
                        layer_schema = layer_schema[1:-1]
                        self.getNewTreeVal(parent, layer_name, layer_meta, layer_schema)
                        layer.setMetadata(layer_meta)
                        dict_inspire = self.dictTreeInspireVal()
            self.LayersTree()
            self.setTree()
            self.setTreeINSPIRE_NewVal(dict_inspire)
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            msg.setText("Vos fiches sont à jour!")
            msg.setWindowTitle("Info!")
            msg.exec_()

    def getNewTreeVal(self, root, parent_text, metadata, layer_schema):
        """_summary_

        Cette fonction permet de récupérer les nouvelles métadonnées saisies par l'utilisateur dans le plugin, et les insérer dans la fiche de métadonnées.

        Args:
            root (treeWidget): objet qui représente la couche.
            parent_text (str): nom du parent(par exemple nom de la couche).
            metadata (objet Qgis):  un objet qui contient les informations de métadonnées de la couche.
            layer_schema (str) : nom du schema d'une couche.
        """
        connexion = self.ConnexionPostgresql()[1]
        cur = connexion.cursor()
        themes_inspire = None
        categories = None
        mots_clefs = None
        description = None
        Licence = None
        title = None
        for i in range(root.childCount()):
            parent = root.child(i)
            if parent.text(1) == parent_text:
                id_objet = metadata.identifier()
                for j in range(parent.childCount()):
                    child = parent.child(j)
                    widget = self.treeWidget.itemWidget(child, 3)
                    if child.text(2) == "Thèmes INSPIRE":
                        selected_inspire = widget.checkedItems()
                        value = []
                        for item in selected_inspire:
                            escaped_item = item.replace("'", "''")
                            value.append(escaped_item)
                        if value != "":
                            themes_inspire = value
                    elif child.text(2) == "Mots-clés":
                        value = widget.text()
                        if value != "":
                            mot = ""
                            listMot = []
                            if value:
                                for lettre in value:
                                    if lettre == ",":
                                        listMot.append(mot)
                                        mot = ""
                                    elif lettre != "":
                                        mot += lettre
                                listMot.append(mot)
                            for item in listMot[::-1]:
                                if item == "":
                                    listMot.remove(item)
                            metadata.setKeywords(
                                {
                                    "": listMot,
                                }
                            )
                            mots_clefs_escaped = []
                            for item in listMot:
                                escaped_item = item.replace("'", "''")
                                mots_clefs_escaped.append(escaped_item)
                            mots_clefs = mots_clefs_escaped
                    elif child.text(2) == "Catégories":
                        selected_cat = widget.checkedItems()
                        value = []
                        for item in selected_cat:
                            if item in self.dict_cat_iso:
                                value.append(self.dict_cat_iso[item])
                        modified_value = [item.replace("'", "''") for item in value]
                        if value != "":
                            metadata.setCategories(value)
                            categories = modified_value
                    elif child.text(2) == "titre":
                        value = widget.text()
                        title = value
                        metadata.setTitle(value)
                    elif child.text(2) == "Résumé de la couche":
                        value = widget.toPlainText()
                        metadata.setAbstract(value)
                        if value != "":
                            description = value
                    elif child.text(2) == "Licence":
                        value = widget.currentText()
                        link_metro = QgsAbstractMetadataBase.Link()
                        link_metro.name = "Grenoble-Alpes Métropole"
                        link_metro.type = "https"
                        link_metro.description = "Site de la Métropole"
                        link_metro.url = " https://www.grenoblealpesmetropole.fr/"
                        link_metro.format = "HTTPS"

                        list_links = [link_metro]

                        link_wms = QgsAbstractMetadataBase.Link()
                        link_wms.name = parent_text
                        link_wms.type = "OGC-WMS Capabilities service (ver 1.3.0)"
                        link_wms.description = parent_text
                        link_wms.url = (
                            "https://geoflux.grenoblealpesmetropole.fr/geoserver/"
                            + layer_schema
                            + "/ows?SERVICE=WMS&"
                        )
                        link_wms.format = "WMS"

                        link_kml = QgsAbstractMetadataBase.Link()
                        link_kml.name = "Format KML"
                        link_kml.type = "WWW:DOWNLOAD-1.0-http--download"
                        link_kml.description = parent_text
                        link_kml.url = (
                            "https://geoflux.grenoblealpesmetropole.fr/geoserver/"
                            + layer_schema
                            + "/ows?service=WFS&version=1.0.0&request=GetFeature&typeName="
                            + layer_schema
                            + "%3A"
                            + parent_text
                            + "&outputFormat=kml"
                        )
                        link_kml.format = "KML"

                        link_geojson = QgsAbstractMetadataBase.Link()
                        link_geojson.name = "Format Geojson"
                        link_geojson.type = "WWW:DOWNLOAD-1.0-http--download"
                        link_geojson.description = parent_text
                        link_geojson.url = (
                            "https://geoflux.grenoblealpesmetropole.fr/geoserver/"
                            + layer_schema
                            + "/ows?service=WFS&version=1.0.0&request=GetFeature&typeName="
                            + layer_schema
                            + "%3A"
                            + parent_text
                            + "&outputFormat=application%2Fjson"
                        )
                        link_geojson.format = "GeoJSON"

                        metadata.setLicenses([value])
                        Licence = value
                        if value == "Licence ouverte (OpenDATA)":
                            params_WMS = {
                                "request": "GetCapabilities",
                                "service": "WMS",
                            }
                            response_wms = requests.get(link_wms.url, params=params_WMS)
                            response_kml = requests.get(link_kml.url)
                            response_geojson = requests.get(link_kml.url)
                            if response_kml.status_code == 200:
                                list_links.append(link_kml)
                            if response_geojson.status_code == 200:
                                list_links.append(link_geojson)
                            if response_wms.status_code == 200:
                                list_links.append(link_wms)
                            metadata.setLinks(list_links)
                        else:
                            metadata.setLinks(list_links)
                update_requete = f'UPDATE sit_hydre.gest_bdd_rel_objets_thematique SET metadonnees = \'{{"licences": {json.dumps(Licence)},"categories": {json.dumps(categories)}, "mots_clefs": {json.dumps(mots_clefs)}, "themes_inspire": {json.dumps(themes_inspire)}}}\' WHERE objet_id = \'{id_objet}\' AND niveau = 1'
                if description != None:
                    description = description.replace("'", "''")
                    update_requete2 = f"UPDATE sit_hydre.gest_bdd_rel_objets_thematique SET metadonnees_commentaire = '{description}' WHERE objet_id = '{id_objet}' AND niveau = 1"
                    cur.execute(update_requete2)
                if title != None:
                    update_title_requete = f"UPDATE sit_hydre.gest_bdd_rel_objets_thematique SET metadonnees_titre = '{title}' WHERE objet_id = '{id_objet}' AND niveau = 1"
                    cur.execute(update_title_requete)
                cur.execute(update_requete)
                connexion.commit()
        cur.close()
        connexion.close()

    def getTreeInspireVal(self, layer_name):
        """_summary_

        Fonction qui récupere uniquement les nouvelles valeurs concernant les thémes INSPIRE.

        Args:
            layer_name (str): nom de la couche.
        """
        root = self.treeWidget.invisibleRootItem()
        for i in range(root.childCount()):
            parent = root.child(i)
            if parent.text(1) == layer_name:
                for j in range(parent.childCount()):
                    child = parent.child(j)
                    widget = self.treeWidget.itemWidget(child, 3)
                    if child.text(2) == "Thèmes INSPIRE":
                        value = widget.checkedItems()
                        return value

    def dictTreeInspireVal(self):
        """_summary_

        Cette fonction  permet de générer un dictionnaire contenant les valeurs des métadonnées INSPIRE afin de ne pas perdre cette information qui n'est pas implémentée dans Qgis.

        """
        inspire_dict = {}
        for i in range(self.treeWidget.topLevelItemCount()):
            item = self.treeWidget.topLevelItem(i)
            nom_couche = item.text(1)
            inspire_dict[nom_couche] = []
            inspire_val = self.getTreeInspireVal(nom_couche)
            inspire_dict[nom_couche] = inspire_val
        return inspire_dict

    def setTree(self):
        """_summary_

        Cette fonction remplit l'arbre pour chaque couche avec les informations existantes en utilisant la fonction SetTreeItems.

        """
        parent = self.treeWidget.invisibleRootItem()
        project = QgsProject.instance()
        for layer in project.mapLayers().values():
            layer_meta = layer.metadata()
            layer_name = layer.name()
            if len(self.layers_niveau) > 0:
                if self.layers_niveau.get(layer_name) == 1:
                    self.setTreeItems(parent, layer_name, layer_meta)

    def setTreeINSPIRE_NewVal(self, INSPIRE_dict):
        """_summary_

        Cette fonction remplie la partie des valeurs INSPIRE par les valeurs INSPIRE saisies par l'utilisateur auparavant.

        Args:
            INSPIRE_dict (dict): dictionnaire des valeurs INSPIRE qui ont été saisies par l'utilisateur.
        """
        root = self.treeWidget.invisibleRootItem()
        for i in range(root.childCount()):
            parent = root.child(i)
            for j in range(parent.childCount()):
                child = parent.child(j)
                widget = self.treeWidget.itemWidget(child, 3)
                if child.text(2) == "Thèmes INSPIRE":
                    widget.setCheckedItems(INSPIRE_dict[parent.text(1)])

    def getInspireFromBD(self, metadata):
        INSPIRE = None
        tab_meta = self.getMetadataTab()
        for obj in tab_meta:
            id_objet = obj.get("objet_id")
            if id_objet == metadata.identifier():
                INSPIRE = obj.get("metadonnees")["themes_inspire"]
        return INSPIRE

    def setTreeItems(self, root, parent_text, metadata):
        """_summary_

        Fonction qui remplie les champs vides dans l'arbre par les données correspondantes depuis la fiche de métadonnées.

        Args:
            root (treeWidget): objet qui représente la couche.
            parent_text (str): nom du parent(par exemple nom de la couche).
            metadata (objet Qgis):  un objet qui contient les informations de métadonnées de la couche.
        """
        for i in range(root.childCount()):
            parent = root.child(i)
            if parent.text(1) == parent_text:
                for j in range(parent.childCount()):
                    child = parent.child(j)
                    widget = self.treeWidget.itemWidget(child, 3)
                    if child.text(2) == "Thèmes INSPIRE":
                        list_INSPIRE = self.getInspireFromBD(metadata)
                        if list_INSPIRE != None:
                            widget.setCheckedItems(list_INSPIRE)
                    elif child.text(2) == "Mots-clés":
                        keywords = metadata.keywords()
                        for key in keywords:
                            if key == "":
                                widget.setText(",".join(keywords[key]))
                    elif child.text(2) == "Catégories":
                        categories_selected = metadata.categories()
                        keys_selected = [
                            k
                            for k, v in self.dict_cat_iso.items()
                            if v in categories_selected
                        ]
                        widget.setCheckedItems(keys_selected)
                    elif child.text(2) == "Licence":
                        if metadata.licenses() != []:
                            Licence_selected = metadata.licenses()[0]
                        else:
                            Licence_selected = ""
                        widget.setCurrentText(Licence_selected)
                        if widget.currentIndex() == 0:
                            child.setForeground(2, QColor(255, 165, 0))

    def checkTreeTitle(self):
        """_summary_

        Fonction qui vérifie que toutes les fiches de métadonnées ont un titre.

        """
        res = True
        root = self.treeWidget.invisibleRootItem()
        for i in range(root.childCount()):
            parent = root.child(i)
            checkbox = self.treeWidget.itemWidget(parent, 0)
            for j in range(parent.childCount()):
                child = parent.child(j)
                if child.text(2) == "titre" and checkbox.isChecked():
                    res = False
        return res

    def treeLayersColor(self):
        """_summary_

        Fonction qui met en place les couleurs des champs de métadonnées dans l'arbre en fonction de ce qui est remplis ou pas.

        """
        root = self.treeWidget.invisibleRootItem()
        for i in range(root.childCount()):
            has_title = False
            parent = root.child(i)
            for j in range(parent.childCount()):
                child = parent.child(j)
                widget = self.treeWidget.itemWidget(child, 3)
                if child.text(2) == "titre":
                    parent.setForeground(1, QColor("red"))
                    has_title = True
                elif child.text(2) == "Résumé de la couche" or (
                    child.text(2) == "Licence" and widget.currentIndex() == 0
                ):
                    if has_title:
                        parent.setForeground(1, QColor("red"))
                    else:
                        parent.setForeground(1, QColor("orange"))
                else:
                    parent.setForeground(1, QColor("green"))

    def get_tree_checkbox_status(self):
        """_summary_

        Fonction permet de récuperer la valeur pour le checkbox Geonetwork si ca a été coché ou non.

        """
        checkbox_status = {}
        root = self.treeWidget.invisibleRootItem()
        for i in range(root.childCount()):
            parent = root.child(i)
            checkbox = self.treeWidget.itemWidget(parent, 0)
            checkbox_status[i] = checkbox.isChecked()
        # Stocker le dictionnaire en tant qu'attribut du plugin
        self.tree_checkbox_status = checkbox_status
        # print('checkbox : '+ str(checkbox_status) )

    def set_tree_checkbox_status(self):
        """_summary_

        Fonction qui met en place les checkboxes.

        """
        if not hasattr(self, "tree_checkbox_status"):
            return
        checkbox_status = self.tree_checkbox_status
        root = self.treeWidget.invisibleRootItem()
        for i in range(root.childCount()):
            parent = root.child(i)
            checkbox = self.treeWidget.itemWidget(parent, 0)
            if i in checkbox_status:
                checkbox.setChecked(checkbox_status[i])

    def getAuthGN(self):
        """_summary_

        Fonction qui récupere les identifiants saisies par l'utilisateur.

        Returns:
            username (str): nom d'utilisateur saisie dans le plugin.
            motdepass (str): mot de pass saisie dans le plugin.
        """
        username = self.leUsername.text()
        motdepass = self.lePassword.text()
        return (username, motdepass)

    def checkConnexionGN(self):
        """_summary_

        Fonction qui vérifie la connexion vers le geonetwork et envoie un message en fonction de la réponse.

        """
        username = self.getAuthGN()[0]
        motdepass = self.getAuthGN()[1]
        if username == "" and motdepass == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Vous n'avez pas saisie de username ni de mot de pass")
            msg.setWindowTitle("Erreur!!")
            msg.exec_()
        elif username == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Vous n'avez pas saisie de username")
            msg.setWindowTitle("Erreur!!")
            msg.exec_()
        elif motdepass == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Vous n'avez pas saisie de mot de pass")
            msg.setWindowTitle("Erreur!!")
            msg.exec_()
        else:
            if connexionGeonetwork(username, motdepass)[0]:
                self.pbPost.setVisible(True)
                self.label_3.setVisible(True)
            else:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Username ou mot de pass incorrecte!!")
                msg.setWindowTitle("Erreur!!")
                msg.exec_()

    def populateTabGN(self):
        """_summary_

        Fonction qui va gérérer l'affichage des fiches qui sont à envoyer au geonetwork dans le tableau de la fenetre geonetwork.

        """
        connexion = self.ConnexionPostgresql()[1]
        cur = connexion.cursor()
        catalogGN = (
            os.environ.get(
                "GN_URL", "https://geonetwork.grenoblealpesmetropole.fr/geonetwork"
            )
            + "/srv/fre/catalog.search#/metadata/"
        )
        self.model = QStandardItemModel(0, 2)
        self.model.setHorizontalHeaderLabels(
            ["Couches", "Lien vers les fiches métadonnées dans Geonetwork"]
        )
        project = QgsProject.instance()
        for i, layer in enumerate(project.mapLayers().values()):
            layer_name = layer.name()
            layer_meta = layer.metadata()
            uuid = layer_meta.identifier()
            # print('uuid : %',uuid)
            MetaID = self.getMetaID(uuid)
            if self.tree_checkbox_status != None:
                if self.tree_checkbox_status.get(i):
                    MetaID = MetaID[0]
                    item1 = QStandardItem(layer_name)
                    item2 = QStandardItem(catalogGN + MetaID)
                    item2.setForeground(QBrush(QColor("blue"), style=Qt.SolidPattern))
                    item2.setTextAlignment(Qt.AlignCenter)
                    item2.setSelectable(True)
                    item2.setEditable(False)
                    item2.setData(
                        catalogGN + MetaID, Qt.UserRole
                    )  # Stocke l'URL dans les données utilisateur
                    self.model.appendRow([item1, item2])
                    Meta_lien = catalogGN + MetaID
                    update_MetaLink = f"UPDATE sit_hydre.gest_bdd_rel_objets_thematique SET metadonnees_lien = '{Meta_lien}', metadonnees_titre = '{layer_name}' WHERE metadonnees_id = '{MetaID}'"
                    cur.execute(update_MetaLink)
                    connexion.commit()
        cur.close()
        connexion.close()
        self.tableGN.setModel(self.model)
        self.tableGN.setColumnWidth(1, 450)
        self.tableGN.setColumnWidth(0, 250)

    def onTableGNDoubleClick(self, index):
        """_summary_

        Fonction qui est appelé lorsqu'on clique deux fois sur une cellule de la table des liens geonetwork.Son rôle est de récupérer l'URL stockée dans les données utilisateur de la cellule correspondante, puis d'ouvrir cette URL dans le navigateur par défaut

        Args:
            index (objet): représente l'index de la cellule double-cliquée.
        """
        row = index.row()
        col = index.column()
        if col == 1:  # Vérifie que la cellule double-cliquée est la deuxième colonne
            url = self.model.item(row, col).data(Qt.UserRole)
            QDesktopServices.openUrl(QUrl(url))

    def getLayerType(self, layer):
        # Déterminer le type de la couche
        if isinstance(layer, QgsMapLayer):
            if layer.type() == QgsMapLayerType.VectorLayer:
                if layer.geometryType() == QgsWkbTypes.NullGeometry:
                    layer_type = "textTable"
                else:
                    layer_type = "vector"
            elif (
                layer.type() == QgsMapLayerType.RasterLayer
                or layer.type() == QgsMapLayerType.TileLayer
            ):
                layer_type = "grid"
            else:
                layer_type = "unknown"
        return layer_type

    def getLayerDenominateur(self, layer):
        layer_extent = layer.extent()
        layer_scale = max(layer_extent.width(), layer_extent.height())
        arrondis = [
            1000,
            5000,
            10000,
            25000,
            50000,
            100000,
            200000,
            300000,
            500000,
            1000000,
        ]
        echelle_arrondie = min(arrondis, key=lambda x: abs(x - layer_scale))
        return echelle_arrondie

    def addInspire_to_xml(self):
        """_summary_

        Fonction qui permet de créer le fichier .zip contenant toutes les information d'une fiche de métadonnées à l'aide de la fonction createZip.
        Mais aussi permet d'ajouter les valeurs INSPIRE dans la partie xml de ce fichier.

        """
        project = QgsProject.instance()
        username = self.getAuthGN()[0]
        motdepass = self.getAuthGN()[1]
        for i, layer in enumerate(project.mapLayers().values()):
            layer_name = layer.name()
            layer_meta = layer.metadata()
            uuid = layer_meta.identifier()
            MetaID = self.getMetaID(uuid)
            Inspire_keywords = self.getTreeInspireVal(layer_name)
            self.get_tree_checkbox_status()
            if MetaID != None:
                if self.tree_checkbox_status != None:
                    LayerType = self.getLayerType(layer)
                    LayerDominateur = self.getLayerDenominateur(layer)
                    if self.tree_checkbox_status.get(i):
                        MetaID = MetaID[0]
                        datePublication = getMetaDateGN(username, motdepass, MetaID)
                        createZip(
                            layer_name,
                            MetaID,
                            Inspire_keywords,
                            LayerType,
                            LayerDominateur,
                            datePublication,
                        )
                        print(
                            """nom layer : """
                            + str(layer_name)
                            + """
                                uuid : """
                            + str(uuid)
                            + """
                                UUID méta : """
                            + str(MetaID)
                            + """
                                Métadonnées : """
                            + str(Inspire_keywords)
                            + """
                                Type : """
                            + str(LayerType)
                            + """
                                Dominateur : """
                            + str(LayerDominateur)
                            + """
                                Date publication : """
                            + str(datePublication)
                            + """
                                envoi sur geonetwork : OK """
                        )

    def launch_MetaPost(self):
        """_summary_

        Gestion du répertoire temporaire temp et envoie des fiches vers le geonetwork.

        """
        removeAllZipFiles()
        self.addInspire_to_xml()
        cleanTemp()
        connexionGN = self.getAuthGN()
        postMetaGN(connexionGN[0], connexionGN[1])
        removeAllZipFiles()

    def updateProgressBar(self):
        """_summary_

        Gestion des messages d'erreur. Et mise à jour de la barre d'évolution.

        """
        self.progressBar.setRange(0, 100)
        self.progressBar.setValue(0)
        if self.checkTreeTitle() == True:
            self.launch_MetaPost()
            self.populateTabGN()
            self.progressBar.setValue(100)
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText(
                "Vous n'avez pas saisie un titre pour la couche à envoyer! \n- Retournez dans ''Gestion de métadonnées'' et ajouter un titre à l'endroit ou il n'y en a pas pour la couche en question. \n- Ensuite sauvegarder les modifications."
            )
            msg.setWindowTitle("Erreur!!")
            msg.exec_()
